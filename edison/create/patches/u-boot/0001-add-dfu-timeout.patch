From b1d09a269b11e21ca255a186261737f9d2ba9bbd Mon Sep 17 00:00:00 2001
From: Brad <bradjc5@gmail.com>
Date: Mon, 22 May 2017 16:49:54 -0400
Subject: [PATCH] add dfu timeout

---
 cmd/dfu.c                  | 11 +++++++++++
 common/dfu.c               | 14 ++++++++++++++
 configs/edison_defconfig   |  1 +
 drivers/dfu/Kconfig        |  6 ++++++
 drivers/dfu/dfu.c          | 27 +++++++++++++++++++++++++++
 drivers/usb/gadget/f_dfu.c |  2 ++
 include/dfu.h              |  4 ++++
 7 files changed, 65 insertions(+)

diff --git a/cmd/dfu.c b/cmd/dfu.c
index 04291f6c08..71fac0a3cf 100644
--- a/cmd/dfu.c
+++ b/cmd/dfu.c
@@ -49,6 +49,10 @@ static int do_dfu(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		dfu_show_entities();
 		goto done;
 	}
+#ifdef CONFIG_DFU_TIMEOUT
+	if (argc > 4)
+		dfu_set_timeout(simple_strtoul(argv[4], NULL, 0) * 1000);
+#endif
 
 	int controller_index = simple_strtoul(usb_controller, NULL, 0);
 
@@ -61,11 +65,18 @@ done:
 
 U_BOOT_CMD(dfu, CONFIG_SYS_MAXARGS, 1, do_dfu,
 	"Device Firmware Upgrade",
+#ifdef CONFIG_DFU_TIMEOUT
+	"<USB_controller> <interface> <dev> [list|timeout]\n"
+#else
 	"<USB_controller> <interface> <dev> [list]\n"
+#endif
 	"  - device firmware upgrade via <USB_controller>\n"
 	"    on device <dev>, attached to interface\n"
 	"    <interface>\n"
 	"    [list] - list available alt settings\n"
+#ifdef CONFIG_DFU_TIMEOUT
+	"    [timeout] - specify inactivity timeout in sec, doesn't work with list\n"
+#endif
 #ifdef CONFIG_DFU_TFTP
 	"dfu tftp <interface> <dev> [<addr>]\n"
 	"  - device firmware upgrade via TFTP\n"
diff --git a/common/dfu.c b/common/dfu.c
index 0e9f5f59c8..eb46115186 100644
--- a/common/dfu.c
+++ b/common/dfu.c
@@ -35,6 +35,9 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 		error("g_dnl_register failed");
 		return CMD_RET_FAILURE;
 	}
+#ifdef CONFIG_DFU_TIMEOUT
+	ulong time_activity_start = get_timer(0);
+#endif
 
 	while (1) {
 		if (g_dnl_detach()) {
@@ -80,6 +83,17 @@ int run_usb_dnl_gadget(int usbctrl_index, char *usb_dnl_gadget)
 			}
 		}
 
+#ifdef CONFIG_DFU_TIMEOUT
+		if (!dfu_enum_done()) {
+			ulong cur_time = get_timer(time_activity_start);
+
+			if (cur_time > dfu_get_timeout()) {
+				debug("\nInactivity Timeout, Abort Dfu\n");
+				goto exit;
+			}
+		}
+#endif
+
 		WATCHDOG_RESET();
 		usb_gadget_handle_interrupts(usbctrl_index);
 	}
diff --git a/configs/edison_defconfig b/configs/edison_defconfig
index 53476fdaf7..f9bfc4d82b 100644
--- a/configs/edison_defconfig
+++ b/configs/edison_defconfig
@@ -22,6 +22,7 @@ CONFIG_SYSCON=y
 CONFIG_CPU=y
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
+CONFIG_DFU_TIMEOUT=y
 CONFIG_MMC=y
 CONFIG_DM_MMC=y
 CONFIG_MMC_SDHCI=y
diff --git a/drivers/dfu/Kconfig b/drivers/dfu/Kconfig
index 56a98f5273..97e8071819 100644
--- a/drivers/dfu/Kconfig
+++ b/drivers/dfu/Kconfig
@@ -12,6 +12,12 @@ config DFU_TFTP
 
 	  Detailed description of this feature can be found at ./doc/README.dfutftp
 
+config DFU_TIMEOUT
+	bool "Timeout waiting for DFU"
+	help
+	  This option adds an optional timeout parameter for DFU which, if set,
+	  will cause DFU to only wait for that many seconds before exiting.
+
 config DFU_MMC
 	bool "MMC back end for DFU"
 	help
diff --git a/drivers/dfu/dfu.c b/drivers/dfu/dfu.c
index 8dacc1a6d1..10314e6525 100644
--- a/drivers/dfu/dfu.c
+++ b/drivers/dfu/dfu.c
@@ -17,10 +17,14 @@
 #include <linux/list.h>
 #include <linux/compiler.h>
 
+static bool dfu_enum_request;
 static LIST_HEAD(dfu_list);
 static int dfu_alt_num;
 static int alt_num_cnt;
 static struct hash_algo *dfu_hash_algo;
+#ifdef CONFIG_DFU_TIMEOUT
+static ulong dfu_timeout = 0;
+#endif
 
 /*
  * The purpose of the dfu_usb_get_reset() function is to
@@ -38,6 +42,28 @@ __weak bool dfu_usb_get_reset(void)
 	return true;
 }
 
+bool dfu_enum_done(void)
+{
+	return dfu_enum_request;
+}
+
+void dfu_trigger_enum_done()
+{
+	dfu_enum_request = true;
+}
+
+#ifdef CONFIG_DFU_TIMEOUT
+void dfu_set_timeout(ulong timeout)
+{
+	dfu_timeout = timeout;
+}
+
+ulong dfu_get_timeout()
+{
+	return dfu_timeout;
+}
+#endif
+
 static int dfu_find_alt_num(const char *s)
 {
 	int i = 0;
@@ -71,6 +97,7 @@ int dfu_init_env_entities(char *interface, char *devstr)
 		return ret;
 	}
 
+	dfu_enum_request = false;
 	free(env_bkp);
 	return 0;
 }
diff --git a/drivers/usb/gadget/f_dfu.c b/drivers/usb/gadget/f_dfu.c
index dfa4359577..35a5db17f2 100644
--- a/drivers/usb/gadget/f_dfu.c
+++ b/drivers/usb/gadget/f_dfu.c
@@ -596,6 +596,8 @@ dfu_handle(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 	debug("req_type: 0x%x ctrl->bRequest: 0x%x f_dfu->dfu_state: 0x%x\n",
 	       req_type, ctrl->bRequest, f_dfu->dfu_state);
 
+	dfu_trigger_enum_done();
+
 	if (req_type == USB_TYPE_STANDARD) {
 		if (ctrl->bRequest == USB_REQ_GET_DESCRIPTOR &&
 		    (w_value >> 8) == DFU_DT_FUNC) {
diff --git a/include/dfu.h b/include/dfu.h
index f39d3f1171..d7508b401e 100644
--- a/include/dfu.h
+++ b/include/dfu.h
@@ -152,12 +152,16 @@ const char *dfu_get_layout(enum dfu_layout l);
 struct dfu_entity *dfu_get_entity(int alt);
 char *dfu_extract_token(char** e, int *n);
 void dfu_trigger_reset(void);
+void dfu_trigger_enum_done(void);
 int dfu_get_alt(char *name);
 int dfu_init_env_entities(char *interface, char *devstr);
 unsigned char *dfu_get_buf(struct dfu_entity *dfu);
+bool dfu_enum_done(void);
 unsigned char *dfu_free_buf(void);
 unsigned long dfu_get_buf_size(void);
 bool dfu_usb_get_reset(void);
+ulong dfu_get_timeout(void);
+void dfu_set_timeout(ulong);
 
 int dfu_read(struct dfu_entity *de, void *buf, int size, int blk_seq_num);
 int dfu_write(struct dfu_entity *de, void *buf, int size, int blk_seq_num);
-- 
2.11.0

